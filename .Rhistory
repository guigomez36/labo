#creo un ctr_quarter que tenga en cuenta cuando los clientes hace 3 menos meses que estan
dataset[  , ctrx_quarter_normalizado := ctrx_quarter ]
dataset[ cliente_antiguedad==1 , ctrx_quarter_normalizado := ctrx_quarter * 5 ]
dataset[ cliente_antiguedad==2 , ctrx_quarter_normalizado := ctrx_quarter * 2 ]
dataset[ cliente_antiguedad==3 , ctrx_quarter_normalizado := ctrx_quarter * 1.2 ]
#variable extraida de una tesis de maestria de Irlanda
dataset[  , mpayroll_sobre_edad  := mpayroll / cliente_edad ]
#se crean los nuevos campos para MasterCard  y Visa, teniendo en cuenta los NA's
#varias formas de combinar Visa_status y Master_status
dataset[ , mv_status01       := pmax( Master_status,  Visa_status, na.rm = TRUE) ]
dataset[ , mv_status02       := Master_status +  Visa_status ]
dataset[ , mv_status03       := pmax( ifelse( is.na(Master_status), 10, Master_status) , ifelse( is.na(Visa_status), 10, Visa_status) ) ]
dataset[ , mv_status04       := ifelse( is.na(Master_status), 10, Master_status)  +  ifelse( is.na(Visa_status), 10, Visa_status)  ]
dataset[ , mv_status05       := ifelse( is.na(Master_status), 10, Master_status)  +  100*ifelse( is.na(Visa_status), 10, Visa_status)  ]
dataset[ , mv_status06       := ifelse( is.na(Visa_status),
ifelse( is.na(Master_status), 10, Master_status),
Visa_status)  ]
dataset[ , mv_status07       := ifelse( is.na(Master_status),
ifelse( is.na(Visa_status), 10, Visa_status),
Master_status)  ]
#combino MasterCard y Visa
dataset[ , mv_mfinanciacion_limite := rowSums( cbind( Master_mfinanciacion_limite,  Visa_mfinanciacion_limite) , na.rm=TRUE ) ]
dataset[ , mv_Fvencimiento         := pmin( Master_Fvencimiento, Visa_Fvencimiento, na.rm = TRUE) ]
dataset[ , mv_Finiciomora          := pmin( Master_Finiciomora, Visa_Finiciomora, na.rm = TRUE) ]
dataset[ , mv_msaldototal          := rowSums( cbind( Master_msaldototal,  Visa_msaldototal) , na.rm=TRUE ) ]
dataset[ , mv_msaldopesos          := rowSums( cbind( Master_msaldopesos,  Visa_msaldopesos) , na.rm=TRUE ) ]
dataset[ , mv_msaldodolares        := rowSums( cbind( Master_msaldodolares,  Visa_msaldodolares) , na.rm=TRUE ) ]
dataset[ , mv_mconsumospesos       := rowSums( cbind( Master_mconsumospesos,  Visa_mconsumospesos) , na.rm=TRUE ) ]
dataset[ , mv_mconsumosdolares     := rowSums( cbind( Master_mconsumosdolares,  Visa_mconsumosdolares) , na.rm=TRUE ) ]
dataset[ , mv_mlimitecompra        := rowSums( cbind( Master_mlimitecompra,  Visa_mlimitecompra) , na.rm=TRUE ) ]
dataset[ , mv_madelantopesos       := rowSums( cbind( Master_madelantopesos,  Visa_madelantopesos) , na.rm=TRUE ) ]
dataset[ , mv_madelantodolares     := rowSums( cbind( Master_madelantodolares,  Visa_madelantodolares) , na.rm=TRUE ) ]
dataset[ , mv_fultimo_cierre       := pmax( Master_fultimo_cierre, Visa_fultimo_cierre, na.rm = TRUE) ]
dataset[ , mv_mpagado              := rowSums( cbind( Master_mpagado,  Visa_mpagado) , na.rm=TRUE ) ]
dataset[ , mv_mpagospesos          := rowSums( cbind( Master_mpagospesos,  Visa_mpagospesos) , na.rm=TRUE ) ]
dataset[ , mv_mpagosdolares        := rowSums( cbind( Master_mpagosdolares,  Visa_mpagosdolares) , na.rm=TRUE ) ]
dataset[ , mv_fechaalta            := pmax( Master_fechaalta, Visa_fechaalta, na.rm = TRUE) ]
dataset[ , mv_mconsumototal        := rowSums( cbind( Master_mconsumototal,  Visa_mconsumototal) , na.rm=TRUE ) ]
dataset[ , mv_cconsumos            := rowSums( cbind( Master_cconsumos,  Visa_cconsumos) , na.rm=TRUE ) ]
dataset[ , mv_cadelantosefectivo   := rowSums( cbind( Master_cadelantosefectivo,  Visa_cadelantosefectivo) , na.rm=TRUE ) ]
dataset[ , mv_mpagominimo          := rowSums( cbind( Master_mpagominimo,  Visa_mpagominimo) , na.rm=TRUE ) ]
#a partir de aqui juego con la suma de Mastercard y Visa
dataset[ , mvr_Master_mlimitecompra:= Master_mlimitecompra / mv_mlimitecompra ]
dataset[ , mvr_Visa_mlimitecompra  := Visa_mlimitecompra / mv_mlimitecompra ]
dataset[ , mvr_msaldototal         := mv_msaldototal / mv_mlimitecompra ]
dataset[ , mvr_msaldopesos         := mv_msaldopesos / mv_mlimitecompra ]
dataset[ , mvr_msaldopesos2        := mv_msaldopesos / mv_msaldototal ]
dataset[ , mvr_msaldodolares       := mv_msaldodolares / mv_mlimitecompra ]
dataset[ , mvr_msaldodolares2      := mv_msaldodolares / mv_msaldototal ]
dataset[ , mvr_mconsumospesos      := mv_mconsumospesos / mv_mlimitecompra ]
dataset[ , mvr_mconsumosdolares    := mv_mconsumosdolares / mv_mlimitecompra ]
dataset[ , mvr_madelantopesos      := mv_madelantopesos / mv_mlimitecompra ]
dataset[ , mvr_madelantodolares    := mv_madelantodolares / mv_mlimitecompra ]
dataset[ , mvr_mpagado             := mv_mpagado / mv_mlimitecompra ]
dataset[ , mvr_mpagospesos         := mv_mpagospesos / mv_mlimitecompra ]
dataset[ , mvr_mpagosdolares       := mv_mpagosdolares / mv_mlimitecompra ]
dataset[ , mvr_mconsumototal       := mv_mconsumototal  / mv_mlimitecompra ]
dataset[ , mvr_mpagominimo         := mv_mpagominimo  / mv_mlimitecompra ]
# quito las columnas que tienen alta correlacion con otras o muchos nulos del dataset
# quito tambien las variables que tienen poco peso en el arbol original al quitar las xx1. 1 orden de magnitud por debajo de las principales
#==================================================================================================================
xx1 <- c("mcomisiones_mantenimiento","Visa_mpagado", "ctarjeta_visa_transacciones","ctarjeta_visa_debitos_automaticos","mttarjeta_visa_debitos_automaticos","mtarjeta_visa_consumo","Master_Finiciomora","mtarjeta_master_consumo","Visa_msaldototal","Visa_msaldopesos","Master_mpagospesos","Master_mconsumospesos","ctarjeta_visa_transacciones","ctarjeta_visa_transacciones","ctarjeta_master_transacciones","Master_msaldopesos","Master_msaldopesos","cextraccion_autoservicio","Visa_msaldopesos","ccajas_transacciones","mtarjeta_master_consumo","ctarjeta_master","mtarjeta_master_consumo","Visa_msaldototal","Master_msaldototal","Master_msaldototal","mpayroll2","Visa_msaldopesos","Visa_msaldopesos","Visa_mconsumospesos","Visa_mconsumototal","mtarjeta_visa_consumo","ctarjeta_visa_transacciones","mtarjeta_master_consumo","mtarjeta_visa_consumo","tcallcenter","cprestamos_hipotecarios","mcaja_ahorro_dolares","Visa_msaldototal","Visa_msaldototal","Master_msaldopesos","ctarjeta_visa_transacciones","Visa_mpagospesos","mpasivos_margen","Visa_madelantopesos","ctarjeta_master_debitos_automaticos","mtarjeta_visa_consumo","Visa_mconsumospesos","Visa_mpagospesos","cextraccion_autoservicio","ctarjeta_debito_transacciones","mrentabilidad","cextraccion_autoservicio","ccomisiones_mantenimiento","ctarjeta_visa_debitos_automaticos","Master_msaldototal","mextraccion_autoservicio","mtarjeta_visa_consumo","catm_trx","cforex","cliente_antiguedad","cforex","ctarjeta_master_transacciones","catm_trx_other","Master_fechaalta","ctarjeta_visa_transacciones","mextraccion_autoservicio","Master_msaldodolares","mtarjeta_master_consumo","mtarjeta_master_consumo","cliente_antiguedad","mtarjeta_visa_consumo","mtarjeta_visa_consumo","Visa_msaldodolares","Master_madelantopesos","cforex_sell","Master_msaldototal","Master_mlimitecompra","Visa_msaldototal","mcomisiones","Visa_mconsumospesos","Master_mconsumospesos","Master_mpagado","cplazo_fijo","Master_madelantodolares","Master_mpagosdolares","cseguro_accidentes_personales","Visa_delinquency","Master_cadelantosefectivo","ccaja_ahorro","cseguro_vida","Visa_cadelantosefectivo","matm_other","cpagomiscuentas","ccuenta_debitos_automaticos","Visa_mpagosdolares","Master_fultimo_cierre","Master_mconsumosdolares","Visa_fultimo_cierre","internet","mplazo_fijo_dolares","Visa_mlimitecompra","matm","ctarjeta_debito","mpagomiscuentas","ctransferencias_emitidas","ctransferencias_recibidas","Master_mconsumototal","Master_cconsumos","Visa_mconsumosdolares","Visa_mfinanciacion_limite","mtransferencias_emitidas","Master_mpagominimo","thomebanking","mtransferencias_recibidas","cmobile_app_trx","mcuenta_debitos_automaticos","ccaja_seguridad","ccallcenter_transacciones","mautoservicio","Visa_Fvencimiento","Master_mfinanciacion_limite","chomebanking_transacciones","Visa_status","cprestamos_personales","ccomisiones_otras","ccajas_consultas","Master_Fvencimiento")
# vector of columns you DON'T want
#xx2 <- c("Visa_mpagado","ctarjeta_visa_debitos_automaticos","Visa_cconsumos","Visa_cconsumos","mttarjeta_visa_debitos_automaticos","Visa_Finiciomora","Master_cconsumos","Visa_mpagospesos","Visa_mpagospesos","Master_mconsumototal","Master_mpagospesos","Visa_mconsumospesos","Visa_mconsumototal","mtarjeta_master_consumo","Master_mconsumototal","Master_mconsumospesos","matm","Visa_mpagominimo","ccajas_extracciones","Master_mpagospesos","Master_status","Master_msaldopesos","Visa_mpagominimo","Master_mconsumototal","Master_mconsumospesos","cpayroll2_trx","Visa_mconsumototal","Visa_mconsumospesos","Visa_cconsumos","Visa_cconsumos","Visa_msaldopesos","Visa_mpagospesos","Master_msaldototal","Visa_msaldototal","ccallcenter_transacciones","mprestamos_hipotecarios","mcuentas_saldo","Visa_mconsumototal","Visa_mconsumospesos","Master_mpagominimo","mtarjeta_visa_consumo","Visa_cconsumos","mcaja_ahorro","Visa_cadelantosefectivo","mttarjeta_master_debitos_automaticos","Visa_cconsumos","Visa_mpagospesos","Visa_mconsumototal","mextraccion_autoservicio","mautoservicio","mrentabilidad_annual","catm_trx","mcomisiones_mantenimiento","mttarjeta_visa_debitos_automaticos","Master_mpagominimo","catm_trx","Visa_mpagospesos","matm","mforex_sell","Master_fechaalta","cforex_sell","Master_cconsumos","matm_other","Visa_fechaalta","Visa_cconsumos","matm","Master_mconsumosdolares","Master_mconsumototal","Master_mconsumospesos","Visa_fechaalta","Visa_mconsumototal","Visa_mconsumospesos","Visa_mconsumosdolares","Master_cadelantosefectivo","mforex_sell","Master_msaldopesos","Visa_mlimitecompra","Visa_msaldopesos","mcomisiones_otras","Visa_mconsumototal","Master_mconsumototal")
# subset
dataset <- dataset[, !xx1, with = FALSE]
#==================================================================================================================
#===============================================================================
#paso la clase a binaria que tome valores {0,1}  enteros
#set trabaja con la clase  POS = { BAJA+1, BAJA+2 }
#esta estrategia es MUY importante
dataset[ , clase01 := ifelse( clase_ternaria %in%  c("BAJA+2","BAJA+1"), 1L, 0L) ]
#--------------------------------------
#los campos que se van a utilizar
campos_buenos  <- setdiff( colnames(dataset), c("clase_ternaria","clase01") )
#--------------------------------------
#establezco donde entreno
dataset[ , train  := 0L ]
dataset[ foto_mes %in% PARAM$input$training, train  := 1L ]
#--------------------------------------
#creo las carpetas donde van los resultados
#creo la carpeta donde va el experimento
# HT  representa  Hiperparameter Tuning
dir.create( "C:\\DataMining_Economia_Finanzas\\",  showWarnings = FALSE )
dir.create( paste0("C:\\DataMining_Economia_Finanzas\\exp\\", PARAM$experimento, "/" ), showWarnings = FALSE )
setwd( paste0("C:\\DataMining_Economia_Finanzas\\exp\\", PARAM$experimento, "/" ) )   #Establezco el Working Directory DEL EXPERIMENTO
#dejo los datos en el formato que necesita LightGBM
dtrain  <- lgb.Dataset( data= data.matrix(  dataset[ train==1L, campos_buenos, with=FALSE]),
label= dataset[ train==1L, clase01] )
#genero el modelo
#estos hiperparametros  salieron de una laaarga Optmizacion Bayesiana
modelo  <- lgb.train( data= dtrain,
param= list( objective=          "binary",
max_bin=            PARAM$finalmodel$max_bin,
learning_rate=      PARAM$finalmodel$learning_rate,
num_iterations=     PARAM$finalmodel$num_iterations,
num_leaves=         PARAM$finalmodel$num_leaves,
min_data_in_leaf=   PARAM$finalmodel$min_data_in_leaf,
feature_fraction=   PARAM$finalmodel$feature_fraction,
seed=               PARAM$finalmodel$semilla
)
)
lgb.importance(modelo )
#--------------------------------------
#ahora imprimo la importancia de variables
tb_importancia  <-  as.data.table( lgb.importance(modelo) )
archivo_importancia  <- "impo.txt"
fwrite( tb_importancia,
file= archivo_importancia,
sep= "\t" )
#--------------------------------------
#aplico el modelo a los datos sin clase
dapply  <- dataset[ foto_mes== PARAM$input$future ]
#aplico el modelo a los datos nuevos
prediccion  <- predict( modelo,
data.matrix( dapply[, campos_buenos, with=FALSE ])                                 )
#genero la tabla de entrega
tb_entrega  <-  dapply[ , list( numero_de_cliente, foto_mes ) ]
tb_entrega[  , prob := prediccion ]
#grabo las probabilidad del modelo
fwrite( tb_entrega,
file= "prediccion.txt",
sep= "\t" )
#ordeno por probabilidad descendente
setorder( tb_entrega, -prob )
#genero archivos con los  "envios" mejores
#deben subirse "inteligentemente" a Kaggle para no malgastar submits
cortes <- seq( 5000, 12000, by=500 )
for( envios  in  cortes )
{
tb_entrega[  , Predicted := 0L ]
tb_entrega[ 1:envios, Predicted := 1L ]
fwrite( tb_entrega[ , list(numero_de_cliente, Predicted)],
file= paste0(  PARAM$experimento, "_", envios, ".csv" ),
sep= "," )
}
#--------------------------------------
#quit( save= "no" )
# para correr el Google Cloud
#   8 vCPU
#  64 GB memoria RAM
# 256 GB espacio en disco
# son varios archivos, subirlos INTELIGENTEMENTE a Kaggle
#limpio la memoria
rm( list=ls() )  #remove all objects
gc()             #garbage collection
require("data.table")
require("lightgbm")
#defino los parametros de la corrida, en una lista, la variable global  PARAM
#  muy pronto esto se leera desde un archivo formato .yaml
PARAM <- list()
PARAM$experimento  <- "HT7231_lgbm_4"
PARAM$input$dataset       <- "C:\\DataMining_Economia_Finanzas\\datasets\\competencia2_2022.csv.gz"
PARAM$input$training      <- c( 202103 )
PARAM$input$future        <- c( 202105 )
PARAM$finalmodel$max_bin           <-     31
PARAM$finalmodel$learning_rate     <-      0.0600302856196296   #0.0142501265
PARAM$finalmodel$num_iterations    <-    120  #615
PARAM$finalmodel$num_leaves        <-   918  #784
PARAM$finalmodel$min_data_in_leaf  <-   6979  #5628
PARAM$finalmodel$feature_fraction  <-      0.750648554996587  #0.8382482539
PARAM$finalmodel$semilla           <- 100069
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#Aqui empieza el programa
setwd( "C:\\DataMining_Economia_Finanzas\\" )
#cargo el dataset donde voy a entrenar
dataset  <- fread(PARAM$input$dataset, stringsAsFactors= TRUE)
#creo un ctr_quarter que tenga en cuenta cuando los clientes hace 3 menos meses que estan
dataset[  , ctrx_quarter_normalizado := ctrx_quarter ]
dataset[ cliente_antiguedad==1 , ctrx_quarter_normalizado := ctrx_quarter * 5 ]
dataset[ cliente_antiguedad==2 , ctrx_quarter_normalizado := ctrx_quarter * 2 ]
dataset[ cliente_antiguedad==3 , ctrx_quarter_normalizado := ctrx_quarter * 1.2 ]
#variable extraida de una tesis de maestria de Irlanda
dataset[  , mpayroll_sobre_edad  := mpayroll / cliente_edad ]
#se crean los nuevos campos para MasterCard  y Visa, teniendo en cuenta los NA's
#varias formas de combinar Visa_status y Master_status
dataset[ , mv_status01       := pmax( Master_status,  Visa_status, na.rm = TRUE) ]
dataset[ , mv_status02       := Master_status +  Visa_status ]
dataset[ , mv_status03       := pmax( ifelse( is.na(Master_status), 10, Master_status) , ifelse( is.na(Visa_status), 10, Visa_status) ) ]
dataset[ , mv_status04       := ifelse( is.na(Master_status), 10, Master_status)  +  ifelse( is.na(Visa_status), 10, Visa_status)  ]
dataset[ , mv_status05       := ifelse( is.na(Master_status), 10, Master_status)  +  100*ifelse( is.na(Visa_status), 10, Visa_status)  ]
dataset[ , mv_status06       := ifelse( is.na(Visa_status),
ifelse( is.na(Master_status), 10, Master_status),
Visa_status)  ]
dataset[ , mv_status07       := ifelse( is.na(Master_status),
ifelse( is.na(Visa_status), 10, Visa_status),
Master_status)  ]
#combino MasterCard y Visa
dataset[ , mv_mfinanciacion_limite := rowSums( cbind( Master_mfinanciacion_limite,  Visa_mfinanciacion_limite) , na.rm=TRUE ) ]
dataset[ , mv_Fvencimiento         := pmin( Master_Fvencimiento, Visa_Fvencimiento, na.rm = TRUE) ]
dataset[ , mv_Finiciomora          := pmin( Master_Finiciomora, Visa_Finiciomora, na.rm = TRUE) ]
dataset[ , mv_msaldototal          := rowSums( cbind( Master_msaldototal,  Visa_msaldototal) , na.rm=TRUE ) ]
dataset[ , mv_msaldopesos          := rowSums( cbind( Master_msaldopesos,  Visa_msaldopesos) , na.rm=TRUE ) ]
dataset[ , mv_msaldodolares        := rowSums( cbind( Master_msaldodolares,  Visa_msaldodolares) , na.rm=TRUE ) ]
dataset[ , mv_mconsumospesos       := rowSums( cbind( Master_mconsumospesos,  Visa_mconsumospesos) , na.rm=TRUE ) ]
dataset[ , mv_mconsumosdolares     := rowSums( cbind( Master_mconsumosdolares,  Visa_mconsumosdolares) , na.rm=TRUE ) ]
dataset[ , mv_mlimitecompra        := rowSums( cbind( Master_mlimitecompra,  Visa_mlimitecompra) , na.rm=TRUE ) ]
dataset[ , mv_madelantopesos       := rowSums( cbind( Master_madelantopesos,  Visa_madelantopesos) , na.rm=TRUE ) ]
dataset[ , mv_madelantodolares     := rowSums( cbind( Master_madelantodolares,  Visa_madelantodolares) , na.rm=TRUE ) ]
dataset[ , mv_fultimo_cierre       := pmax( Master_fultimo_cierre, Visa_fultimo_cierre, na.rm = TRUE) ]
dataset[ , mv_mpagado              := rowSums( cbind( Master_mpagado,  Visa_mpagado) , na.rm=TRUE ) ]
dataset[ , mv_mpagospesos          := rowSums( cbind( Master_mpagospesos,  Visa_mpagospesos) , na.rm=TRUE ) ]
dataset[ , mv_mpagosdolares        := rowSums( cbind( Master_mpagosdolares,  Visa_mpagosdolares) , na.rm=TRUE ) ]
dataset[ , mv_fechaalta            := pmax( Master_fechaalta, Visa_fechaalta, na.rm = TRUE) ]
dataset[ , mv_mconsumototal        := rowSums( cbind( Master_mconsumototal,  Visa_mconsumototal) , na.rm=TRUE ) ]
dataset[ , mv_cconsumos            := rowSums( cbind( Master_cconsumos,  Visa_cconsumos) , na.rm=TRUE ) ]
dataset[ , mv_cadelantosefectivo   := rowSums( cbind( Master_cadelantosefectivo,  Visa_cadelantosefectivo) , na.rm=TRUE ) ]
dataset[ , mv_mpagominimo          := rowSums( cbind( Master_mpagominimo,  Visa_mpagominimo) , na.rm=TRUE ) ]
#a partir de aqui juego con la suma de Mastercard y Visa
dataset[ , mvr_Master_mlimitecompra:= Master_mlimitecompra / mv_mlimitecompra ]
dataset[ , mvr_Visa_mlimitecompra  := Visa_mlimitecompra / mv_mlimitecompra ]
dataset[ , mvr_msaldototal         := mv_msaldototal / mv_mlimitecompra ]
dataset[ , mvr_msaldopesos         := mv_msaldopesos / mv_mlimitecompra ]
dataset[ , mvr_msaldopesos2        := mv_msaldopesos / mv_msaldototal ]
dataset[ , mvr_msaldodolares       := mv_msaldodolares / mv_mlimitecompra ]
dataset[ , mvr_msaldodolares2      := mv_msaldodolares / mv_msaldototal ]
dataset[ , mvr_mconsumospesos      := mv_mconsumospesos / mv_mlimitecompra ]
dataset[ , mvr_mconsumosdolares    := mv_mconsumosdolares / mv_mlimitecompra ]
dataset[ , mvr_madelantopesos      := mv_madelantopesos / mv_mlimitecompra ]
dataset[ , mvr_madelantodolares    := mv_madelantodolares / mv_mlimitecompra ]
dataset[ , mvr_mpagado             := mv_mpagado / mv_mlimitecompra ]
dataset[ , mvr_mpagospesos         := mv_mpagospesos / mv_mlimitecompra ]
dataset[ , mvr_mpagosdolares       := mv_mpagosdolares / mv_mlimitecompra ]
dataset[ , mvr_mconsumototal       := mv_mconsumototal  / mv_mlimitecompra ]
dataset[ , mvr_mpagominimo         := mv_mpagominimo  / mv_mlimitecompra ]
# quito las columnas que tienen alta correlacion con otras o muchos nulos del dataset
# quito tambien las variables que tienen poco peso en el arbol original al quitar las xx1. 1 orden de magnitud por debajo de las principales
#==================================================================================================================
xx1 <- c("mcomisiones_mantenimiento","Visa_mpagado", "ctarjeta_visa_transacciones","ctarjeta_visa_debitos_automaticos","mttarjeta_visa_debitos_automaticos","mtarjeta_visa_consumo","Master_Finiciomora","mtarjeta_master_consumo","Visa_msaldototal","Visa_msaldopesos","Master_mpagospesos","Master_mconsumospesos","ctarjeta_visa_transacciones","ctarjeta_visa_transacciones","ctarjeta_master_transacciones","Master_msaldopesos","Master_msaldopesos","cextraccion_autoservicio","Visa_msaldopesos","ccajas_transacciones","mtarjeta_master_consumo","ctarjeta_master","mtarjeta_master_consumo","Visa_msaldototal","Master_msaldototal","Master_msaldototal","mpayroll2","Visa_msaldopesos","Visa_msaldopesos","Visa_mconsumospesos","Visa_mconsumototal","mtarjeta_visa_consumo","ctarjeta_visa_transacciones","mtarjeta_master_consumo","mtarjeta_visa_consumo","tcallcenter","cprestamos_hipotecarios","mcaja_ahorro_dolares","Visa_msaldototal","Visa_msaldototal","Master_msaldopesos","ctarjeta_visa_transacciones","Visa_mpagospesos","mpasivos_margen","Visa_madelantopesos","ctarjeta_master_debitos_automaticos","mtarjeta_visa_consumo","Visa_mconsumospesos","Visa_mpagospesos","cextraccion_autoservicio","ctarjeta_debito_transacciones","mrentabilidad","cextraccion_autoservicio","ccomisiones_mantenimiento","ctarjeta_visa_debitos_automaticos","Master_msaldototal","mextraccion_autoservicio","mtarjeta_visa_consumo","catm_trx","cforex","cliente_antiguedad","cforex","ctarjeta_master_transacciones","catm_trx_other","Master_fechaalta","ctarjeta_visa_transacciones","mextraccion_autoservicio","Master_msaldodolares","mtarjeta_master_consumo","mtarjeta_master_consumo","cliente_antiguedad","mtarjeta_visa_consumo","mtarjeta_visa_consumo","Visa_msaldodolares","Master_madelantopesos","cforex_sell","Master_msaldototal","Master_mlimitecompra","Visa_msaldototal","mcomisiones","Visa_mconsumospesos","Master_mconsumospesos","Master_mpagado","cplazo_fijo","Master_madelantodolares","Master_mpagosdolares","cseguro_accidentes_personales","Visa_delinquency","Master_cadelantosefectivo","ccaja_ahorro","cseguro_vida","Visa_cadelantosefectivo","matm_other","cpagomiscuentas","ccuenta_debitos_automaticos","Visa_mpagosdolares","Master_fultimo_cierre","Master_mconsumosdolares","Visa_fultimo_cierre","internet","mplazo_fijo_dolares","Visa_mlimitecompra","matm","ctarjeta_debito","mpagomiscuentas","ctransferencias_emitidas","ctransferencias_recibidas","Master_mconsumototal","Master_cconsumos","Visa_mconsumosdolares","Visa_mfinanciacion_limite","mtransferencias_emitidas","Master_mpagominimo","thomebanking","mtransferencias_recibidas","cmobile_app_trx","mcuenta_debitos_automaticos","ccaja_seguridad","ccallcenter_transacciones","mautoservicio","Visa_Fvencimiento","Master_mfinanciacion_limite","chomebanking_transacciones","Visa_status","cprestamos_personales","ccomisiones_otras","ccajas_consultas","Master_Fvencimiento")
# vector of columns you DON'T want
#xx2 <- c("Visa_mpagado","ctarjeta_visa_debitos_automaticos","Visa_cconsumos","Visa_cconsumos","mttarjeta_visa_debitos_automaticos","Visa_Finiciomora","Master_cconsumos","Visa_mpagospesos","Visa_mpagospesos","Master_mconsumototal","Master_mpagospesos","Visa_mconsumospesos","Visa_mconsumototal","mtarjeta_master_consumo","Master_mconsumototal","Master_mconsumospesos","matm","Visa_mpagominimo","ccajas_extracciones","Master_mpagospesos","Master_status","Master_msaldopesos","Visa_mpagominimo","Master_mconsumototal","Master_mconsumospesos","cpayroll2_trx","Visa_mconsumototal","Visa_mconsumospesos","Visa_cconsumos","Visa_cconsumos","Visa_msaldopesos","Visa_mpagospesos","Master_msaldototal","Visa_msaldototal","ccallcenter_transacciones","mprestamos_hipotecarios","mcuentas_saldo","Visa_mconsumototal","Visa_mconsumospesos","Master_mpagominimo","mtarjeta_visa_consumo","Visa_cconsumos","mcaja_ahorro","Visa_cadelantosefectivo","mttarjeta_master_debitos_automaticos","Visa_cconsumos","Visa_mpagospesos","Visa_mconsumototal","mextraccion_autoservicio","mautoservicio","mrentabilidad_annual","catm_trx","mcomisiones_mantenimiento","mttarjeta_visa_debitos_automaticos","Master_mpagominimo","catm_trx","Visa_mpagospesos","matm","mforex_sell","Master_fechaalta","cforex_sell","Master_cconsumos","matm_other","Visa_fechaalta","Visa_cconsumos","matm","Master_mconsumosdolares","Master_mconsumototal","Master_mconsumospesos","Visa_fechaalta","Visa_mconsumototal","Visa_mconsumospesos","Visa_mconsumosdolares","Master_cadelantosefectivo","mforex_sell","Master_msaldopesos","Visa_mlimitecompra","Visa_msaldopesos","mcomisiones_otras","Visa_mconsumototal","Master_mconsumototal")
# subset
dataset <- dataset[, !xx1, with = FALSE]
#==================================================================================================================
#===============================================================================
#paso la clase a binaria que tome valores {0,1}  enteros
#set trabaja con la clase  POS = { BAJA+1, BAJA+2 }
#esta estrategia es MUY importante
dataset[ , clase01 := ifelse( clase_ternaria %in%  c("BAJA+2","BAJA+1"), 1L, 0L) ]
#--------------------------------------
#los campos que se van a utilizar
campos_buenos  <- setdiff( colnames(dataset), c("clase_ternaria","clase01") )
#--------------------------------------
#establezco donde entreno
dataset[ , train  := 0L ]
dataset[ foto_mes %in% PARAM$input$training, train  := 1L ]
#--------------------------------------
#creo las carpetas donde van los resultados
#creo la carpeta donde va el experimento
# HT  representa  Hiperparameter Tuning
dir.create( "C:\\DataMining_Economia_Finanzas\\",  showWarnings = FALSE )
dir.create( paste0("C:\\DataMining_Economia_Finanzas\\exp\\", PARAM$experimento, "/" ), showWarnings = FALSE )
setwd( paste0("C:\\DataMining_Economia_Finanzas\\exp\\", PARAM$experimento, "/" ) )   #Establezco el Working Directory DEL EXPERIMENTO
#dejo los datos en el formato que necesita LightGBM
dtrain  <- lgb.Dataset( data= data.matrix(  dataset[ train==1L, campos_buenos, with=FALSE]),
label= dataset[ train==1L, clase01] )
#genero el modelo
#estos hiperparametros  salieron de una laaarga Optmizacion Bayesiana
modelo  <- lgb.train( data= dtrain,
param= list( objective=          "binary",
max_bin=            PARAM$finalmodel$max_bin,
learning_rate=      PARAM$finalmodel$learning_rate,
num_iterations=     PARAM$finalmodel$num_iterations,
num_leaves=         PARAM$finalmodel$num_leaves,
min_data_in_leaf=   PARAM$finalmodel$min_data_in_leaf,
feature_fraction=   PARAM$finalmodel$feature_fraction,
seed=               PARAM$finalmodel$semilla
)
)
lgb.importance(modelo )
#--------------------------------------
#ahora imprimo la importancia de variables
tb_importancia  <-  as.data.table( lgb.importance(modelo) )
archivo_importancia  <- "impo.txt"
fwrite( tb_importancia,
file= archivo_importancia,
sep= "\t" )
#--------------------------------------
#aplico el modelo a los datos sin clase
dapply  <- dataset[ foto_mes== PARAM$input$future ]
#aplico el modelo a los datos nuevos
prediccion  <- predict( modelo,
data.matrix( dapply[, campos_buenos, with=FALSE ])                                 )
#genero la tabla de entrega
tb_entrega  <-  dapply[ , list( numero_de_cliente, foto_mes ) ]
tb_entrega[  , prob := prediccion ]
#grabo las probabilidad del modelo
fwrite( tb_entrega,
file= "prediccion.txt",
sep= "\t" )
#ordeno por probabilidad descendente
setorder( tb_entrega, -prob )
#genero archivos con los  "envios" mejores
#deben subirse "inteligentemente" a Kaggle para no malgastar submits
cortes <- seq( 5000, 12000, by=500 )
for( envios  in  cortes )
{
tb_entrega[  , Predicted := 0L ]
tb_entrega[ 1:envios, Predicted := 1L ]
fwrite( tb_entrega[ , list(numero_de_cliente, Predicted)],
file= paste0(  PARAM$experimento, "_", envios, ".csv" ),
sep= "," )
}
#--------------------------------------
#quit( save= "no" )
##
## Sobre El Futuro
##
## ---------------------------
## Step 1: Setup
## ---------------------------
##
## The future is not something to predict. The future is something to build.
## --- Franco Ongaro
# Profundizaremos en los puntos de corte.
# IMPORTANTE: En esta competencia se puede entrenar usando Marzo. Sin embargo,
# vamos aprovechar (y recomendar que usted también lo haga) Enero para
# experimentar contra Marzo.
rm(list = ls())
gc(verbose = FALSE)
# Librerías necesarias
require("data.table")
require("rpart")
require("ggplot2")
require("lightgbm")
# Poner la carpeta de la materia de SU computadora local
setwd("C:\\DataMining_Economia_Finanzas\\")
# Poner sus semillas
semillas <- c(100069,100103,100109,100129,100151)
# Cargamos los datasets y nos quedamos solo con 202101 y 202103
dataset <- fread("C:\\DataMining_Economia_Finanzas\\datasets\\competencia2_2022.csv.gz")
enero <- dataset[foto_mes == 202101]
marzo <- dataset[foto_mes == 202103]
rm(dataset)
clase_binaria <- ifelse(enero$clase_ternaria == "CONTINUA", 0, 1)
enero$clase_ternaria <- NULL
## ---------------------------
## Step 2: Un modelo simple de LGBM
## ---------------------------
# Armamos el dataset de train para LGBM
dtrain  <- lgb.Dataset(data = data.matrix(enero), label = clase_binaria)
model_lgm <- lightgbm(data = dtrain,
nrounds = 100,
params = list(objective = "binary",
max_bin = 26,
min_data_in_leaf = 1708,
learning_rate = 0.0388101229071701,
num_iterations=263,
num_leaves= 416,
feature_fraction=0.409075453131663 ),
verbose = -1)
## ---------------------------
## Step 3: Veamos como funcionó en Marzo
## ---------------------------
marzo$pred <- predict(model_lgm, data.matrix(marzo[, 1:154]))
sum((marzo$pred > 0.025) * ifelse(marzo$clase_ternaria == "BAJA+2", 78000, -2000))
## ---------------------------
## Step 4: Veamos cuán distintos los scores entregados
## ---------------------------
length(marzo$pred)
length(unique(marzo$pred))
## Preguntas
## - ¿Qué diferencia observa con respecto a ?
## ---------------------------
## Step 4: En el leaderboard público.
## ---------------------------
# Simulamos un Leaderboard público:
set.seed(semillas)
split <- caret::createDataPartition(marzo$clase_ternaria, p = 0.50, list = FALSE)
# Vemos la cantidad de casos que estaríamos mandando:clase_ternaria
sum(marzo$pred > 0.025) # En mi caso dice que estaría mandando 7744
# Y obtendríamos una ganancia de
# Privado
sum((marzo$pred[split] > 0.025) * ifelse(marzo$clase_ternaria[split] == "BAJA+2", 78000, -2000)) / 0.5
# Público
sum((marzo$pred[-split] > 0.025) * ifelse(marzo$clase_ternaria[-split] == "BAJA+2", 78000, -2000)) / 0.5
# Pero... que pasa si mandamos otra cantidad de casos?
# Vamos a mandar los N mejores casos, de a separaciones de M
## ---------------------------
## Step 4: Buscando el mejor punto de corte en el leaderboard público.
## ---------------------------
# Ordenamos el dataset segun su probabilidad de forma ascendente
setorder(marzo, cols = -pred)
# PROBAR MULTIPLES VALORES
set.seed(semillas[3])
m <- 500
f <- 2000
t <- 12000
leaderboad <- data.table()
split <- caret::createDataPartition(marzo$clase_ternaria, p = 0.50, list = FALSE)
marzo$board[split] <- "privado"
marzo$board[-split] <- "publico"
for (s in seq(f, t, m)) {
privado <- marzo[1:s, sum(ifelse(board == "privado",
ifelse(clase_ternaria == "BAJA+2", 78000, -2000), 0)) / 0.5]
publico <- marzo[1:s, sum(ifelse(board == "publico",
ifelse(clase_ternaria == "BAJA+2", 78000, -2000), 0)) / 0.5]
leaderboad <- rbindlist(list(leaderboad,
data.table(envio = s, board = "privado", valor = privado),
data.table(envio = s, board = "publico", valor = publico)
))
}
# Graficamos
ggplot(leaderboad[board == "publico"], aes(x = envio, y = valor, color = board)) + geom_line()
ggplot(leaderboad, aes(x = envio, y = valor, color = board)) + geom_line()
## ACTIVE LEARNING: Juegue con los parámetros y busque si hay alguna información
## en el leaderboard público que le de una estrategia para elegir la cantidad
## adecuada para ganar maximizar la ganancia del privado.
##
## Sobre El Futuro
##
## ---------------------------
## Step 1: Setup
## ---------------------------
##
## The future is not something to predict. The future is something to build.
## --- Franco Ongaro
# Profundizaremos en los puntos de corte.
# IMPORTANTE: En esta competencia se puede entrenar usando Marzo. Sin embargo,
# vamos aprovechar (y recomendar que usted también lo haga) Enero para
# experimentar contra Marzo.
rm(list = ls())
gc(verbose = FALSE)
# Librerías necesarias
require("data.table")
require("rpart")
require("ggplot2")
require("lightgbm")
# Poner la carpeta de la materia de SU computadora local
setwd("C:\\DataMining_Economia_Finanzas\\")
# Poner sus semillas
semillas <- c(100069,100103,100109,100129,100151)
# Cargamos los datasets y nos quedamos solo con 202101 y 202103
dataset <- fread("C:\\DataMining_Economia_Finanzas\\datasets\\competencia2_2022.csv.gz")
enero <- dataset[foto_mes == 202101]
marzo <- dataset[foto_mes == 202103]
rm(dataset)
clase_binaria <- ifelse(enero$clase_ternaria == "CONTINUA", 0, 1)
enero$clase_ternaria <- NULL
## ---------------------------
## Step 2: Un modelo simple de LGBM
## ---------------------------
# Armamos el dataset de train para LGBM
dtrain  <- lgb.Dataset(data = data.matrix(enero), label = clase_binaria)
model_lgm <- lightgbm(data = dtrain,
nrounds = 100,
params = list(objective = "binary",
max_bin = 31,
min_data_in_leaf = 219,
learning_rate = 0.00509300483740619,
num_iterations=880,
num_leaves= 193,
feature_fraction=0.451255307202658 ),
verbose = -1)
## ---------------------------
## Step 3: Veamos como funcionó en Marzo
## ---------------------------
marzo$pred <- predict(model_lgm, data.matrix(marzo[, 1:154]))
sum((marzo$pred > 0.025) * ifelse(marzo$clase_ternaria == "BAJA+2", 78000, -2000))
## ---------------------------
## Step 4: Veamos cuán distintos los scores entregados
## ---------------------------
length(marzo$pred)
length(unique(marzo$pred))
## Preguntas
## - ¿Qué diferencia observa con respecto a ?
## ---------------------------
## Step 4: En el leaderboard público.
## ---------------------------
# Simulamos un Leaderboard público:
set.seed(semillas)
split <- caret::createDataPartition(marzo$clase_ternaria, p = 0.50, list = FALSE)
# Vemos la cantidad de casos que estaríamos mandando:clase_ternaria
sum(marzo$pred > 0.025) # En mi caso dice que estaría mandando 7744
# Y obtendríamos una ganancia de
# Privado
sum((marzo$pred[split] > 0.025) * ifelse(marzo$clase_ternaria[split] == "BAJA+2", 78000, -2000)) / 0.5
# Público
sum((marzo$pred[-split] > 0.025) * ifelse(marzo$clase_ternaria[-split] == "BAJA+2", 78000, -2000)) / 0.5
# Pero... que pasa si mandamos otra cantidad de casos?
# Vamos a mandar los N mejores casos, de a separaciones de M
## ---------------------------
## Step 4: Buscando el mejor punto de corte en el leaderboard público.
## ---------------------------
# Ordenamos el dataset segun su probabilidad de forma ascendente
setorder(marzo, cols = -pred)
# PROBAR MULTIPLES VALORES
set.seed(semillas[3])
m <- 500
f <- 2000
t <- 12000
leaderboad <- data.table()
split <- caret::createDataPartition(marzo$clase_ternaria, p = 0.50, list = FALSE)
marzo$board[split] <- "privado"
marzo$board[-split] <- "publico"
for (s in seq(f, t, m)) {
privado <- marzo[1:s, sum(ifelse(board == "privado",
ifelse(clase_ternaria == "BAJA+2", 78000, -2000), 0)) / 0.5]
publico <- marzo[1:s, sum(ifelse(board == "publico",
ifelse(clase_ternaria == "BAJA+2", 78000, -2000), 0)) / 0.5]
leaderboad <- rbindlist(list(leaderboad,
data.table(envio = s, board = "privado", valor = privado),
data.table(envio = s, board = "publico", valor = publico)
))
}
# Graficamos
ggplot(leaderboad[board == "publico"], aes(x = envio, y = valor, color = board)) + geom_line()
ggplot(leaderboad, aes(x = envio, y = valor, color = board)) + geom_line()
## ACTIVE LEARNING: Juegue con los parámetros y busque si hay alguna información
## en el leaderboard público que le de una estrategia para elegir la cantidad
## adecuada para ganar maximizar la ganancia del privado.
